"""Incorporate numInvalidOKs into Test Table

Classes:
    TestTableGenerationWithInvalidOKs
"""

__all__ = []

import argparse
import time
from os import walk
from pathlib import Path
import sys
from typing import Optional

from edge_deletion_analysis import (
    EdgeDeletionAnalyzer,
)
from planaritytesting_utils import (
    parse_range,
    is_path_to_executable,
    PLANARITY_ALGORITHM_SPECIFIERS,
    EDGE_DELETION_ANALYSIS_SPECIFIERS,
    max_num_edges_for_order,
)
from test_table_generator import (
    TestTableGenerator,
)


class TestTableGenerationWithInvalidOKs:
    """
    Run edge-deletion analysis on all .g6 files for each each edge-count of
    each graph order for which we wish to generate the Test Tables.
    """

    def __init__(
        self,
        planarity_path: Optional[Path] = None,
        orders: Optional[tuple[int, ...]] = None,
        generate_tables_for_commands: Optional[tuple[str, ...]] = None,
        graph_dir: Optional[Path] = None,
        planarity_output_dir: Optional[Path] = None,
        test_table_output_dir: Optional[Path] = None,
        canonical_files: bool = False,
        makeg_files: bool = False,
    ) -> None:
        """Initializes TestTableGeneratorWithInvalidOKs instance

        Args:
            planarity_path: Path to planarity executable to use when running
                edge-deletion analysis. If none provided, defaults to:
                    {planarity_project_root}/Release/planarity
            orders: Graph orders for which to perform edge-deletion analysis
                for relevant graph algorithm extensions and to tabulate results
                of running planarity Test All Graphs
            generate_tables_for_commands: Command specifiers for which you wish
                to generate test tables; defaults to tuple returned by
                PLANARITY_ALGORITHM_SPECIFIERS()
            graph_dir: Path to parent directory containing subdirectories for
                each graph order, the contents of which are .g6 graph files,
                one for each edgecount from 0 to (N * (N - 1)) / 2. If none
                provided, defaults to:
                    TestSupport/results/graph_generation_orchestrator/
            planarity_output_dir: Path to parent directory containing
                subdirectories for each graph order, the contents of which are
                subdirectories for each graph algorithm extension. Each of
                these directories contains the results of running planarity
                Test All Graphs for the given command on all graphs of a given
                order and number of edges. If none provided, defaults to:
                    TestSupport/results/planarity_testAllGraphs_orchestrator/
            test_table_output_dir: Parent directory under which subdirectory
                named after each {order} will be created for output results. If
                none provided, defaults to:
                    TestSupport/tables/
            canonical_files: Whether or not the .g6 files are in canonical form
            makeg_files: Whether or not the .g6 files were generated by makeg

        Raises:
            argparse.ArgumentTypeError: if planarity_path doesn't correspond to
                an executable, if the specified graph orders are invalid, if
                the command specifiers for which you wish to generate test
                tables are invalid, if the graph_dir is invalid, or if the
                planarity_output_dir is invalid
        """
        self.canonical_files = canonical_files
        self.makeg_files = makeg_files

        planarity_project_root = (
            Path(sys.argv[0]).resolve().parent.parent.parent
        )
        if not planarity_path:
            planarity_path = Path.joinpath(
                planarity_project_root, "Release", "planarity"
            )
        if not is_path_to_executable(planarity_path):
            raise argparse.ArgumentTypeError(
                f"Path for planarity executable '{planarity_path}' does not "
                "correspond to an executable."
            )

        self.planarity_path = planarity_path

        if not orders:
            orders = tuple(range(6, 11))  # orders defaults to (6, 7, 8, 9, 10)

        if not all(isinstance(x, int) for x in orders):
            raise argparse.ArgumentTypeError(
                "Orders tuple contains non-integer values."
            )

        self.orders = orders

        if not generate_tables_for_commands:
            generate_tables_for_commands = PLANARITY_ALGORITHM_SPECIFIERS()

        if not all(
            (c in PLANARITY_ALGORITHM_SPECIFIERS())
            for c in generate_tables_for_commands
        ):
            raise argparse.ArgumentTypeError(
                "Invalid command specifier(s) given when indicating which "
                "algorithms for which you wish to generate test tables."
            )

        self.generate_tables_for_commands = generate_tables_for_commands

        self.perform_eda_for_commands = tuple(
            c
            for c in EDGE_DELETION_ANALYSIS_SPECIFIERS()
            if c in self.generate_tables_for_commands
        )

        self.test_support_dir = Path.joinpath(
            planarity_project_root, "TestSupport"
        )

        if not graph_dir:
            graph_dir = Path.joinpath(
                self.test_support_dir,
                "results",
                "graph_generation_orchestrator",
            )

        self._validate_graph_dir(graph_dir)

        self.graph_dir = graph_dir

        if not planarity_output_dir:
            planarity_output_dir = Path.joinpath(
                self.test_support_dir,
                "results",
                "planarity_testAllGraphs_orchestrator",
            )

        self._validate_planarity_output_dir(planarity_output_dir)
        self.planarity_output_dir = planarity_output_dir

        if not test_table_output_dir:
            test_table_output_dir = Path.joinpath(
                self.test_support_dir,
                "tables",
            )
        if test_table_output_dir.is_file():
            raise argparse.ArgumentTypeError(
                f"test_table_output_dir = '{test_table_output_dir}' "
                "corresponds to a file."
            )

        self.test_table_output_dir = test_table_output_dir

        self._numInvalidOKs = {}

    def _input_dir_contains_expected_files(
        self, order: int, input_dir: Path
    ) -> bool:
        """Determines if files in input_dir are named in the expected scheme

        Args:
            order: Files in input_dir are expected to pertain to graphs of the
                given order
            input_dir: Directory containing files to check

        Returns:
            boolean indicating whether (True) or not (False) all files match
                the expected naming scheme, and all expected files are present
        """
        infile_candidate_prefixes = sorted(
            ".".join(infile_candidate.name.split(".")[:2])
            for infile_candidate in input_dir.iterdir()
            if (self.canonical_files == ("canonical" in infile_candidate.name))
            if (self.makeg_files == ("makeg" in infile_candidate.name))
        )
        expected_infile_prefixes = sorted(
            f"n{order}.m{num_edges}"
            for num_edges in range(max_num_edges_for_order(order) + 1)
        )
        return infile_candidate_prefixes == expected_infile_prefixes

    def _validate_graph_dir(self, graph_dir: Path) -> None:
        """Ensure graph_dir contains subdirectories for each order

         Args:
            graph_dir: Path to parent directory containing subdirectories for
                each graph order, the contents of which are .g6 graph files,
                one for each edgecount from 0 to (N * (N - 1)) / 2

        Raises:
            argparse.ArgumentTypeError: If the graph_dir:
                1. corresponds to a file,
                2. contains files,
                3. contains no subdirectories
                4. is missing a subdirectory for one of the desired orders
                Or if the files in the subdirectories are not named in
                the expected scheme
        """
        if graph_dir.is_file():
            raise argparse.ArgumentTypeError(
                f"graph_dir = '{graph_dir}' corresponds to a file."
            )

        for dirpath, dirnames, filenames in walk(graph_dir):
            if len(filenames) > 0:
                raise argparse.ArgumentTypeError(
                    f"graph_dir = '{graph_dir}' has unexpected structure: "
                    "should only contain subdirectories, one for each graph "
                    f"order in {self.orders}."
                )

            if len(dirnames) == 0:
                raise argparse.ArgumentTypeError(
                    f"graph_dir = '{graph_dir}' has no subdirectories: "
                    "expected one subdirectory for each graph order in "
                    f"{self.orders}."
                )

            for order in self.orders:
                if str(order) not in dirnames:
                    raise argparse.ArgumentTypeError(
                        f"graph_dir = '{graph_dir}' is missing subdirectory "
                        f"for graph order N={order}."
                    )
                graph_dir_for_order = Path.joinpath(
                    Path(dirpath).resolve(), f"{order}"
                )
                if not self._input_dir_contains_expected_files(
                    order, graph_dir_for_order
                ):
                    raise argparse.ArgumentTypeError(
                        f"Graph dir for order '{graph_dir_for_order}' doesn't "
                        "contain the expected .g6 infiles (i.e. one per each "
                        f"num_edges for the given order {order})."
                    )
            # Don't recurse into subdirectories
            break

    def _validate_planarity_output_dir(self, planarity_output_dir) -> None:
        """Check planarity output dir has expected subdirectory structure

        Args:
            planarity_output_dir: Path to parent directory containing
                subdirectories for each graph order, the contents of which are
                subdirectories for each graph algorithm extension. Each of
                these directories contains the results of running planarity
                Test All Graphs for the given command on all graphs of a given
                order and number of edges

        Raises:
            argparse.ArgumentTypeError: If the planarity_output_dir:
                1. corresponds to a file,
                2. contains files,
                3. contains no subdirectories
                4. is missing a subdirectory for one of the desired orders
                If, for each of the subdirectories of planarity_output_dir
                containing the results for a specific graph order, the
                directory:
                1. contains files,
                2. contains no subdirectories
                3. is missing a subdirectory for one of the graph algoritm
                command specifiers
                Or if the files in the sub-sub directories are not named in
                the expected scheme
        """
        if planarity_output_dir.is_file():
            raise argparse.ArgumentTypeError(
                f"planarity_output_dir = '{planarity_output_dir}' corresponds "
                "to a file."
            )

        for dirpath, dirnames, filenames in walk(planarity_output_dir):
            if len(filenames) > 0:
                raise argparse.ArgumentTypeError(
                    f"planarity_output_dir = '{planarity_output_dir}' has "
                    "unexpected structure: should only contain "
                    "subdirectories, one for each graph order in "
                    f"{self.orders}."
                )

            if len(dirnames) == 0:
                raise argparse.ArgumentTypeError(
                    f"planarity_output_dir = '{planarity_output_dir}' has no "
                    "subdirectories: expected one subdirectory for each graph "
                    f"order in {self.orders}."
                )

            for order in self.orders:
                if str(order) not in dirnames:
                    raise argparse.ArgumentTypeError(
                        f"planarity_output_dir = '{planarity_output_dir}' is "
                        f"missing subdirectory for graph order N={order}."
                    )

            for dirname in dirnames:
                if int(dirname) not in self.orders:
                    continue

                planarity_output_dir_for_order = Path.joinpath(
                    Path(dirpath).resolve(), dirname
                )
                for _, subdirs, subdir_filenames in walk(
                    planarity_output_dir_for_order
                ):
                    if len(subdir_filenames) > 0:
                        raise argparse.ArgumentTypeError(
                            "Planarity output subdirectory "
                            f"'{planarity_output_dir_for_order}' should only "
                            "contain subdirectories."
                        )

                    if len(dirnames) == 0:
                        raise argparse.ArgumentTypeError(
                            "Planarity output subdirectory "
                            f"'{planarity_output_dir_for_order}' has no "
                            "subdirectories: expected one subdirectory for "
                            "each command specifier in "
                            f"{self.generate_tables_for_commands}."
                        )

                    for command in self.generate_tables_for_commands:
                        if command not in subdirs:
                            raise argparse.ArgumentTypeError(
                                "Planarity output subdirectory "
                                f"'{planarity_output_dir_for_order}' is "
                                "missing subdirectory for command "
                                f"'{command}'."
                            )
                        output_dir_for_order_and_command = Path.joinpath(
                            planarity_output_dir_for_order, f"{command}"
                        )
                        if not self._input_dir_contains_expected_files(
                            int(dirname),
                            output_dir_for_order_and_command,
                        ):
                            raise argparse.ArgumentTypeError(
                                f"Planarity output dir for order and command "
                                f"'{output_dir_for_order_and_command}' "
                                "doesn't contain the expected planarity "
                                "output files (i.e. one per each "
                                f"num_edges for the given order {dirname})."
                            )
                    # Don't recurse into subdirectories
                    break
            # Don't recurse into subdirectories
            break

    def generate_test_tables_with_invalidOKs(self) -> None:
        """For each N, do EDA for applicable commands and generate tables"""
        for order in self.orders:
            self._determine_numInvalidOKs(order)
            self._generate_test_table_with_numInvalidOK(order)

    def _determine_numInvalidOKs(self, order: int) -> None:
        """Run EdgeDeletionAnalyzer on all .g6 input files for the given order

        Args:
            order: The order of graphs on which we wish to perform the edge-
                deletion analysis
        """
        canonical_ext = ".canonical" if self.canonical_files else ""
        makeg_ext = ".makeg" if self.makeg_files else ""

        graph_dir_for_order = Path.joinpath(
            self.graph_dir,
            f"{order}",
        )

        for command in self.perform_eda_for_commands:
            for num_edges in range(max_num_edges_for_order(order) + 1):
                g6_infile_path = Path.joinpath(
                    graph_dir_for_order,
                    f"n{order}.m{num_edges}{makeg_ext}{canonical_ext}.g6",
                )
                self._call_edge_deletion_analysis(
                    order, command, g6_infile_path
                )

    def _call_edge_deletion_analysis(
        self, order: int, command: str, infile_path: Path
    ) -> None:
        """For given command, get numInvalidOKs for each order and edge-count

        Args:
            order: The graph order of the graphs in the input file
            command: string indicating graph search algorithm command specifier
                for which we wish to determine the number of invalid OKs using
                the edge-deletion analysis tool.
            infile_path: The Path of the .g6 input file on which you wish to
                perform the edge-deletion analysis
        """
        eda = EdgeDeletionAnalyzer(
            planarity_path=self.planarity_path,
            infile_path=infile_path,
            output_dir=None,
            extension_choice=command,
        )
        start_proc_time = time.process_time_ns()
        start_time = time.perf_counter_ns()
        numInvalidOK_for_infile = eda.analyze_graphs()
        end_proc_time = time.process_time_ns()
        end_time = time.perf_counter_ns()
        proc_time_s = (end_proc_time - start_proc_time) / 1e9
        tot_time_s = (end_time - start_time) / 1e9

        infile_name = infile_path.name
        eda.logger.info(
            "NUMBER OF INVALID OKs in '%s' is %d; took %fs process time and "
            "%fs total time",
            infile_name,
            numInvalidOK_for_infile,
            proc_time_s,
            tot_time_s,
        )

        if not self._numInvalidOKs.get(order):
            self._numInvalidOKs[order] = {}
        if not self._numInvalidOKs[order].get(command):
            self._numInvalidOKs[order][command] = {}
        self._numInvalidOKs[order][command][infile_name] = {
            "numInvalidOK": numInvalidOK_for_infile,
            "proc_time_s": proc_time_s,
            "tot_time_s": tot_time_s,
        }

    def _generate_test_table_with_numInvalidOK(self, order) -> None:
        """Incorporate edge-deletion analysis results into Test Table

        Args:
            order: The order of graphs on which planarity was run to generate
                the files to be consumed by the test table generator
        """
        input_dir_for_order = Path.joinpath(
            self.planarity_output_dir,
            f"{order}",
        )

        for command in self.generate_tables_for_commands:
            input_dir_for_order_and_command = Path.joinpath(
                input_dir_for_order, f"{command}"
            )
            ttg = TestTableGenerator(
                test_table_input_dir=input_dir_for_order_and_command,
                test_table_output_dir=self.test_table_output_dir,
                canonical_files=self.canonical_files,
                makeg_files=self.makeg_files,
                edge_deletion_analysis_results=self._numInvalidOKs.get(
                    order, {}
                ).get(command, {}),
            )
            ttg.get_order_and_command_from_input_dir()
            ttg.process_files()
            ttg.write_table_formatted_data_to_file()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        usage="python %(prog)s [options]",
        description="Test Table Generation including numInvalidOKs\n\n"
        "For each specified graph order:\n"
        "1. For each edgecount from 0 to (N * (N - 1))/2, runs the "
        "EdgeDeletionAnalyzer for K_{2, 3} search, K_{3, 3} search, and K_4 "
        "search to determine the numInvalidOKs for those graph algorithm "
        "extensions.\n"
        "2. For each of the supported graph algorithms, Tabulates results "
        "from running planarity's Test All Graphs functionality, "
        "incorporating the numInvalidOKs if applicable.\n",
    )
    parser.add_argument(
        "-p",
        "--planaritypath",
        type=Path,
        required=False,
        help="Path to planarity executable. Defaults to:\n"
        "\t{planarity_project_root}/Release/planarity",
        metavar="PATH_TO_PLANARITY_EXECUTABLE",
    )
    parser.add_argument(
        "-n",
        "--orders",
        type=parse_range,
        required=False,
        help="Order(s) of graphs for which you wish to generate Test Tables; "
        f"for commands {EDGE_DELETION_ANALYSIS_SPECIFIERS()}, will include "
        "numInvalidOKs derived by edge-deletion analysis.",
        metavar="X[,Y]",
    )
    parser.add_argument(
        "-c",
        "--gentablecommands",
        nargs="+",
        default=[],
        required=False,
        help="List of algorithm command specifiers for which you wish to "
        "generate test tables. Defaults to "
        f"{PLANARITY_ALGORITHM_SPECIFIERS()}",
    )
    parser.add_argument(
        "-g",
        "--graphdir",
        type=Path,
        required=False,
        help="Path to parent directory containing subdirectories for each "
        "graph order, the contents of which are assumed to be .g6 files (one "
        "for each number of edges from 0 to (N * (N - 1))/2). Defaults to:\n"
        "\tTestSupport/results/graph_generation_orchestrator/",
        metavar="PATH_TO_GRAPH_PARENT_DIR",
    )
    parser.add_argument(
        "-t",
        "--planarityoutputdir",
        type=Path,
        required=False,
        help="Path to parent directory containing subdirectories for each "
        "graph order, the contents of which are subdirectories for each graph "
        f"algorithm extension (i.e. {PLANARITY_ALGORITHM_SPECIFIERS()}). Each "
        "of these directories contains the results of running planarity Test "
        "All Graphs for the given command on all graphs of a given order and "
        "number of edges. Defaults to:\n"
        "\tTestSupport/results/planarity_testAllGraphs_orchestrator/\n"
        "The directories will have the form:\n"
        "\t{planarity_output_dir}/{order}/{command}/\n"
        "And will contain files with names of the form:\n"
        "\tn{order}.m{num_edges}(.makeg)?(.canonical)?.{command}.out.txt",
        metavar="PATH_TO_PLANARITY_OUTPUT",
    )
    parser.add_argument(
        "-o",
        "--outputdir",
        type=Path,
        default=None,
        metavar="OUTPUT_DIR_PATH",
        help="Parent directory under which subdirectory named after each"
        "{order} will be created for output results. If none provided, "
        "defaults to:\n"
        "\tTestSupport/tables/\n"
        "For each chosen order, output file paths have the form:\n"
        "\t{output_dir}/{order}/n{order}.mALL.{command}.out.txt",
    )
    parser.add_argument(
        "-l",
        "--canonicalfiles",
        action="store_true",
        help="Indicates .g6 input files are in canonical form",
    )
    parser.add_argument(
        "-m",
        "--makegfiles",
        action="store_true",
        help="Indicates .g6 input files were generated by makeg",
    )

    args = parser.parse_args()

    eda_ttg = TestTableGenerationWithInvalidOKs(
        planarity_path=args.planaritypath,
        orders=args.orders,
        generate_tables_for_commands=args.gentablecommands,
        graph_dir=args.graphdir,
        planarity_output_dir=args.planarityoutputdir,
        test_table_output_dir=args.outputdir,
        canonical_files=args.canonicalfiles,
        makeg_files=args.makegfiles,
    )

    eda_ttg.generate_test_tables_with_invalidOKs()
